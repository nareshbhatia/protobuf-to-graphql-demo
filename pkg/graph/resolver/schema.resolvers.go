package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.47

import (
	"context"
	"log"

	brandpb "github.com/nareshbhatia/protobuf-to-graphql-demo/gen/go/brand/v1"
	productpb "github.com/nareshbhatia/protobuf-to-graphql-demo/gen/go/product/v1"
	graph1 "github.com/nareshbhatia/protobuf-to-graphql-demo/pkg/graph"
	"github.com/nareshbhatia/protobuf-to-graphql-demo/pkg/graph/model"
)

// Brand is the resolver for the brand field.
func (r *productResolver) Brand(ctx context.Context, obj *model.Product) (*model.Brand, error) {
	req := &brandpb.GetByIDRequest{Id: obj.BrandID}
	res, err := r.brandServiceClient.GetByID(ctx, req)
	if err != nil {
		log.Printf("Error fetching brand: %v", err)
		return nil, err
	}

	// Map the gRPC response to the GraphQL model
	brand := &model.Brand{
		ID:   res.Brand.Id,
		Name: res.Brand.Name,
	}

	return brand, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context) ([]*model.Product, error) {
	req := &productpb.ListProductsRequest{}
	res, err := r.productServiceClient.ListProducts(ctx, req)
	if err != nil {
		log.Printf("Error fetching products: %v", err)
		return nil, err
	}

	// Map the gRPC response to the GraphQL model
	products := make([]*model.Product, len(res.Products))
	for i, product := range res.Products {
		products[i] = &model.Product{
			ID:      product.Id,
			Name:    product.Name,
			BrandID: product.BrandId,
		}
	}

	return products, nil
}

// Product returns graph1.ProductResolver implementation.
func (r *Resolver) Product() graph1.ProductResolver { return &productResolver{r} }

// Query returns graph1.QueryResolver implementation.
func (r *Resolver) Query() graph1.QueryResolver { return &queryResolver{r} }

type productResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
